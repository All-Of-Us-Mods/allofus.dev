<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>IL2CPP Mono Method Analyzer</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      background-color: #f4f4f4;
    }
    h1 {
      margin-bottom: 10px;
    }
    .table-container {
      width: 100%;
      max-height: 65vh;
      overflow-y: auto;
      background-color: white;
      border: 1px solid #ddd;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
      table-layout: fixed;
      margin-top: -1px;
    }
    thead {
      position: sticky;
      top: -1px;
      z-index: 10;
    }
    th, td {
      padding: 6px 8px;
      border: 1px solid #ddd;
      text-align: left;
      word-break: break-word;
      white-space: pre-wrap;
    }
    th {
      background-color: #f0f0f0;
      cursor: pointer;
      position: relative;
      border-top: none;
    }
    th.sort-asc::after {
      content: "▲";
      position: absolute;
      right: 8px;
    }
    th.sort-desc::after {
      content: "▼";
      position: absolute;
      right: 8px;
    }
    th:nth-child(1) { width: 45%; }
    th:nth-child(2) { width: 15%; }
    th:nth-child(3) { width: 7%; }
    th:nth-child(4) { width: 7%; }
    th:nth-child(5) { width: 5%; }
    th:nth-child(6) { width: 11%; }

    .tag {
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.85em;
      font-weight: bold;
      display: inline-block;
    }

    .inlined {
      background-color: #d1e7dd;
      color: #0f5132;
    }

    .used-by-inline {
      background-color: #f8d7da;
      color: #842029;
    }

    .stripped {
      background-color: #e2e3e5;
      color: #41464b;
    }

    .matched {
      background-color: #cfe2ff;
      color: #084298;
    }

    .highlight {
      background-color: yellow;
      font-weight: bold;
    }
    
    .filters {
      display: flex;
      gap: 10px;
      margin: 10px 0;
      flex-wrap: wrap;
    }

    #searchInput, #returnTypeInput, #tagFilter, #typeFilter {
      margin-bottom: 10px;
      padding: 6px 10px;
      box-sizing: border-box;
      flex: 1;
      min-width: 150px;
    }
    #searchInput {
      flex: 4;
    }
    .count-display {
      margin-top: 10px;
      font-size: 20px; 
      color: #222;
      padding: 5px;
      background-color: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 4px;
      display: inline-block;
    }


    .usage-window {
      position: fixed;
      width: 600px;
      max-height: 60vh;
      background-color: white;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      display: flex;
      flex-direction: column;
      z-index: 100;
      right: 20px;
      top: 20px;
      resize: both;
      overflow: hidden;
      min-width: 300px;
      min-height: 200px;
    }

    .usage-window::-webkit-resizer {
      display: none;
    }

    .resize-handle {
      position: absolute;
      right: 0;
      bottom: 0;
      width: 15px;
      height: 15px;
      background: linear-gradient(135deg, #ddd 0%, #ddd 50%, transparent 50%);
      cursor: nwse-resize;
      z-index: 10;
    }

    .usage-window:not(:first-of-type) {
      margin-top: 30px;
    }
    
    .window-header {
      background-color: #f0f0f0;
      padding: 10px 15px;
      cursor: move;
      border-bottom: 1px solid #ddd;
      font-weight: bold;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-top-left-radius: 4px;
      border-top-right-radius: 4px;
      word-break: break-word;
      white-space: pre-wrap;
    }
    
    .window-close {
      cursor: pointer;
      font-size: 36px;
      line-height: 1;
    }
    
    .window-body {
      padding: 15px;
      overflow-y: auto;
      flex-grow: 1;
    }
    
    .usage-item {
      padding: 8px 12px;
      border-bottom: 1px solid #eee;
      font-family: monospace;
      font-size: 13px;
      display: flex;
      align-items: center;
    }
    
    .usage-item:last-child {
      border-bottom: none;
    }
    
    .no-usages {
      color: #666;
      font-style: italic;
    }

    .copy-btn {
      background-color: #f0f0f0;
      border: 1px solid #ddd;
      border-radius: 4px;
      cursor: pointer;
      color: #555;
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-right: 8px;
      padding: 0;
      transition: all 0.2s ease;
      flex-shrink: 0;
    }

    .copy-btn:hover {
      background-color: #e0e0e0;
      color: #333;
    }

    .copy-btn:active {
      background-color: #d0d0d0;
    }

    .copy-btn::before {
      content: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='14' height='14' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Crect x='9' y='9' width='13' height='13' rx='2' ry='2'%3E%3C/rect%3E%3Cpath d='M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1'%3E%3C/path%3E%3C/svg%3E");
      display: inline-block;
      vertical-align: middle;
    }

    .copy-btn.copy-flash::before {
      content: "✓";
      color: green;
    }

    .copy-btn.copy-error::before {
      content: "✗";
      color: red;
    }

    #methodsTable tbody tr {
      cursor: pointer;
    }
    
    #methodsTable tbody tr:hover {
      background-color: #f5f5f5;
    }

    .usage-section {
      margin-bottom: 20px;
    }

    .usage-section h4 {
      margin: 0 0 8px 0;
      padding-bottom: 4px;
      border-bottom: 1px solid #eee;
      color: #555;
    }

    .mono-only {
      background-color: rgba(213, 245, 227, 0.3);
      border-left: 3px solid #0f5132;
      padding-left: 5px;
    }

    .xref-only {
      background-color: rgba(255, 231, 217, 0.3);
      border-left: 3px solid #0f5132;
      padding-left: 5px;
    }

    .usage-item.common {
      border-left: 3px solid #cfe2ff;
      padding-left: 5px;
    }

    .section-header {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      padding: 5px 0;
      user-select: none;
    }

    .section-header h4 {
      margin: 0;
      color: #555;
    }

    .toggle-btn {
      background: none;
      border: none;
      cursor: pointer;
      padding: 0;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      color: #666;
    }

    .section-content {
      padding-left: 20px;
      transition: all 0.2s ease;
    }

    .section-header:hover {
      background-color: #f8f9fa;
    }

    .toggle-btn:hover {
      color: #333;
    }
  
    @keyframes copyFlash {
      0% { color: green; }
      100% { color: #666; }
    }

    .copy-flash {
      animation: copyFlash 1s;
    }
  </style>
</head>
<body>
  <h1>IL2CPP Mono Methods Analyzer</h1>
  <input type="file" id="fileInput" accept="application/json" />
  <div class="filters">
    <input type="text" id="searchInput" placeholder="Search methods..." />
    <input type="text" id="returnTypeInput" placeholder="Search return types..." />
    <select id="tagFilter">
      <option value="">All Tags</option>
      <option value="inlined">Potentially Inlined</option>
      <option value="used-by-inline">Potentially used by Inlined method</option>
      <option value="stripped">Potentially Stripped</option>
      <option value="matched">Matched</option>
    </select>
    <select id="typeFilter">
      <option value="">All Types</option>
      <option value="Method">Method</option>
      <option value="Property">Property</option>
    </select>
  </div>
  <div id="countDisplay" class="count-display">0/0</div>
  <div class="table-container">
    <table id="methodsTable">
      <thead>
        <tr>
          <th data-sort="method">Method</th>
          <th data-sort="ReturnType">Return Type</th>
          <th data-sort="MonoCount">Mono Count</th>
          <th data-sort="XrefCount">Xref Count</th>
          <th data-sort="Type">Type</th>
          <th data-sort="tag">Tag</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <script> 
    let methodData = {};
    let sortField = null;
    let sortAsc = true;
    let searchTimeout = null;
    let totalCount = 0;
    let filteredCount = 0;
    
    const openWindows = new Set();

    function setupCopyButton(button, textToCopy) {
      button.addEventListener('click', (e) => {
          e.stopPropagation();
          navigator.clipboard.writeText(textToCopy).then(() => {
              button.classList.add('copy-flash');
              setTimeout(() => {
                  button.classList.remove('copy-flash');
              }, 1000);
          }).catch(err => {
              button.classList.add('copy-error');
              setTimeout(() => {
                  button.classList.remove('copy-error');
              }, 1000);
              console.error('Failed to copy:', err);
          });
      });
    }

    function createUsageWindow(methodName) {
      const method = methodData[methodName];
      if (!method) return;
          
      const windowEl = document.createElement('div');
      const windowId = 'window-' + Date.now();

      windowEl.className = 'usage-window';
      windowEl.id = windowId;
      
      const header = document.createElement('div');
      header.className = 'window-header';
      
      const title = document.createElement('span');
      title.className = 'window-title';
      title.textContent = `Usages of: ${methodName}`;
      
      const closeBtn = document.createElement('span');
      closeBtn.className = 'window-close';
      closeBtn.textContent = '×';
      
      header.append(title, closeBtn);
      windowEl.append(header);
      
      const body = document.createElement('div');
      body.className = 'window-body';
      
      const monoSection = createUsageSection(
        'Mono Usages', 
        method.MonoUsages, 
        method.XrefUsages,
        'mono-only'
      );
      body.append(monoSection);
      
      const xrefSection = createUsageSection(
        'Xref Usages',
        method.XrefUsages,
        method.MonoUsages,
        'xref-only'
      );
      body.append(xrefSection);
      
      windowEl.append(body);

      const resizeHandle = document.createElement('div');
      resizeHandle.className = 'resize-handle';
      windowEl.appendChild(resizeHandle);

      function createUsageSection(title, items, compareItems, diffClass) {
        const section = document.createElement('div');
        section.className = 'usage-section';
        
        const header = document.createElement('div');
        header.className = 'section-header';
        header.dataset.section = title.toLowerCase().replace(' ', '-');
        
        const toggleBtn = document.createElement('button');
        toggleBtn.className = 'toggle-btn';
        toggleBtn.textContent = '▼';
        
        const titleEl = document.createElement('h4');
        titleEl.textContent = `${title} (${items?.length || 0})`;
        
        header.append(toggleBtn, titleEl);
        section.append(header);
        
        const content = document.createElement('div');
        content.className = `section-content ${header.dataset.section}-section`;
        
        if (!items || items.length === 0) {
            const noItems = document.createElement('div');
            noItems.className = 'no-usages';
            noItems.textContent = `No ${title} found`;
            content.append(noItems);
        } else {
          items.forEach(usage => {
            const item = document.createElement('div');
            item.className = 'usage-item';
            
            // Create copy button (now on LEFT)
            const copyBtn = document.createElement('button');
            copyBtn.className = 'copy-btn';
            copyBtn.title = 'Copy to clipboard';
            
            // Create usage text element
            const usageText = document.createElement('span');
            usageText.textContent = usage;
            usageText.style.flexGrow = '1'; // Take remaining space
            
            // Add elements to item (button first)
            item.append(copyBtn, usageText);
            
            // Set up copy functionality
            setupCopyButton(copyBtn, usage);
            
            // Add diff class if needed
            if (compareItems && !compareItems.includes(usage)) {
                item.classList.add(diffClass);
            }
            
            content.append(item);
          });
        }
        
        section.append(content);
        return section;
    }
      
      windowEl.querySelectorAll('.section-header').forEach(header => {
        header.addEventListener('click', (e) => {
          if (e.target.classList.contains('toggle-btn')) return;
          
          const btn = header.querySelector('.toggle-btn');
          const section = header.nextElementSibling;
          section.style.display = section.style.display === 'none' ? 'block' : 'none';
          btn.textContent = section.style.display === 'none' ? '▶' : '▼';
        });
      });

      windowEl.querySelectorAll('.toggle-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const header = e.target.closest('.section-header');
          const section = header.nextElementSibling;
          section.style.display = section.style.display === 'none' ? 'block' : 'none';
          btn.textContent = section.style.display === 'none' ? '▶' : '▼';
        });
      });
      
      document.body.appendChild(windowEl);
      openWindows.add(windowId);
      
      setupWindowDrag(windowEl);
      setupWindowResize(windowEl, resizeHandle);
      
      closeBtn.addEventListener('click', () => {
        document.body.removeChild(windowEl);
        openWindows.delete(windowId);
      });
      
      return windowEl;
    }
    
    function setupWindowDrag(windowEl) {
      const header = windowEl.querySelector('.window-header');
      let isDragging = false;
      let offsetX, offsetY;
      
      header.addEventListener('mousedown', (e) => {
        if (e.target.classList.contains('window-close') || 
            e.target.classList.contains('resize-handle')) {
          return;
        }
        
        isDragging = true;
        offsetX = e.clientX - windowEl.getBoundingClientRect().left;
        offsetY = e.clientY - windowEl.getBoundingClientRect().top;
        windowEl.style.cursor = 'grabbing';
        e.preventDefault();
      });
      
      document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        
        windowEl.style.left = `${e.clientX - offsetX}px`;
        windowEl.style.top = `${e.clientY - offsetY}px`;
        windowEl.style.right = 'auto';
      });
      
      document.addEventListener('mouseup', () => {
        isDragging = false;
        windowEl.style.cursor = '';
      });
    }
    
    function setupWindowResize(element, handle) {
      let startX, startY, startWidth, startHeight;

      function initResize(e) {
        e.preventDefault();
        startX = e.clientX;
        startY = e.clientY;
        startWidth = parseInt(document.defaultView.getComputedStyle(element).width, 10);
        startHeight = parseInt(document.defaultView.getComputedStyle(element).height, 10);
        document.addEventListener('mousemove', resize);
        document.addEventListener('mouseup', stopResize);
      }

      function resize(e) {
        element.style.width = (startWidth + e.clientX - startX) + 'px';
        element.style.height = (startHeight + e.clientY - startY) + 'px';
      }

      function stopResize() {
        document.removeEventListener('mousemove', resize);
        document.removeEventListener('mouseup', stopResize);
      }

      handle.addEventListener('mousedown', initResize);
    }

    function showUsages(methodName) {
      createUsageWindow(methodName);
    }


    function updateCountDisplay() {
      document.getElementById("countDisplay").textContent = `${filteredCount}/${totalCount}`;
    }

    function highlightMatch(text, filter) {
      if (!filter) return text;
      
      const tempSpan = document.createElement('span');
      tempSpan.innerText = text;
      const escapedText = tempSpan.innerHTML;
      
      const fragment = document.createDocumentFragment();
      const lowerText = escapedText.toLowerCase();
      const lowerFilter = filter.toLowerCase();
      
      let lastIndex = 0;
      let index = lowerText.indexOf(lowerFilter);
      
      while (index !== -1) {
        if (index > lastIndex) {
          const span = document.createElement('span');
          span.innerHTML = escapedText.substring(lastIndex, index);
          fragment.appendChild(span);
        }
        
        const highlight = document.createElement('span');
        highlight.className = 'highlight';
        highlight.innerHTML = escapedText.substring(index, index + filter.length);
        fragment.appendChild(highlight);
        
        lastIndex = index + filter.length;
        index = lowerText.indexOf(lowerFilter, lastIndex);
      }
      
      if (lastIndex < escapedText.length) {
        const span = document.createElement('span');
        span.innerHTML = escapedText.substring(lastIndex);
        fragment.appendChild(span);
      }
      
      const container = document.createElement('div');
      container.appendChild(fragment);
      return container.innerHTML;
    }

    function renderTable(filter = "", returnTypeFilter = "", tagFilter = "", typeFilter = "") {
      requestAnimationFrame(() => {
        const tbody = document.querySelector("#methodsTable tbody");
        tbody.innerHTML = "";

        let entries = Object.entries(methodData).map(([method, { ReturnType, MonoCount, XrefCount, IsProperty, IsStripped }]) => {
          let tag = "Matched";
          let tagClass = "matched";

          if (MonoCount > XrefCount) {
            tag = "Potentially Inlined";
            tagClass = "inlined";
          } else if (XrefCount > MonoCount) {
            tag = "Potentially used by Inlined method";
            tagClass = "used-by-inline";
          }

          if (IsStripped) {
            tag = "Potentially Stripped";
            tagClass = "stripped";
          }

          const type = IsProperty ? "Property" : "Method";

          let rank = 2;
          const lowerMethod = method.toLowerCase();
          const lowerFilter = filter.toLowerCase();
          const lowerReturnType = ReturnType?.toLowerCase() || '';
          const lowerReturnTypeFilter = returnTypeFilter.toLowerCase();

          if (!filter && !returnTypeFilter) {
            rank = -1;
          } else if (lowerMethod === lowerFilter || lowerReturnType === lowerReturnTypeFilter) {
            rank = 0;
          } else if (lowerMethod.includes(lowerFilter) || lowerReturnType.includes(lowerReturnTypeFilter)) {
            rank = 1;
          } else {
            return null;
          }

          return { method, ReturnType, MonoCount, XrefCount, type, tag, tagClass, rank };
        }).filter(Boolean);

        if (totalCount === 0) {
          totalCount = entries.length;
        }
        
        let filteredEntries = entries.filter(entry => {
          const methodMatch = !filter || entry.method.toLowerCase().includes(filter.toLowerCase());
          const returnTypeMatch = !returnTypeFilter || 
                                (entry.ReturnType && entry.ReturnType.toLowerCase().includes(returnTypeFilter.toLowerCase()));
          const tagMatch = !tagFilter || entry.tagClass === tagFilter;
          const typeMatch = !typeFilter || entry.type === typeFilter;
          
          return methodMatch && returnTypeMatch && tagMatch && typeMatch;
        });

        filteredCount = filteredEntries.length;

        filteredEntries.sort((a, b) => {
          if (a.rank !== b.rank) return a.rank - b.rank;
          if (sortField) {
            const valA = a[sortField];
            const valB = b[sortField];
            if (valA < valB) return sortAsc ? -1 : 1;
            if (valA > valB) return sortAsc ? 1 : -1;
            return 0;
          }
          return 0;
        });

        const fragment = document.createDocumentFragment();
        for (const entry of filteredEntries) {
          const row = document.createElement("tr");

          const methodCell = document.createElement("td");
          const methodContainer = document.createElement("div");
          methodContainer.style.display = "flex";
          methodContainer.style.alignItems = "center";
          
          const copyBtn = document.createElement("button");
          copyBtn.className = "copy-btn";
          copyBtn.title = "Copy method name";
          
          const methodText = document.createElement("span");
          if (filter) {
            methodText.innerHTML = highlightMatch(entry.method, filter);
          } else {
            methodText.textContent = entry.method;
          }
          
          methodContainer.append(copyBtn, methodText);
          methodCell.append(methodContainer);
          
          setupCopyButton(copyBtn, entry.method);

          const returnTypeCell = document.createElement("td");
          returnTypeCell.innerText = entry.ReturnType;
          if (returnTypeFilter) {
            returnTypeCell.innerHTML = highlightMatch(entry.ReturnType, returnTypeFilter);
          }
          
          const monoCountCell = document.createElement("td");
          monoCountCell.innerText = entry.MonoCount;
          
          const xrefCountCell = document.createElement("td");
          xrefCountCell.innerText = entry.XrefCount;
          
          const typeCell = document.createElement("td");
          typeCell.innerText = entry.type;
          
          const tagCell = document.createElement("td");
          const tagSpan = document.createElement("span");
          tagSpan.className = `tag ${entry.tagClass}`;
          tagSpan.innerText = entry.tag;
          tagCell.appendChild(tagSpan);
          
          row.append(
            methodCell,
            returnTypeCell,
            monoCountCell,
            xrefCountCell,
            typeCell,
            tagCell
          );
          
          row.addEventListener('click', () => showUsages(entry.method));
          fragment.appendChild(row);
        }
        tbody.appendChild(fragment);
        
        updateCountDisplay();
      });
    }

    function debounce(func, wait) {
      let timeout;
      return function(...args) {
        const context = this;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), wait);
      };
    }

    const debouncedRenderTable = debounce(renderTable, 300);

    document.getElementById("fileInput").addEventListener("change", function (event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function (e) {
        try {
          methodData = JSON.parse(e.target.result);
          totalCount = 0;
          renderTable();
        } catch (err) {
          alert("Invalid JSON file");
          console.error(err);
        }
      };
      reader.readAsText(file);
    });

    document.getElementById("fileInput").addEventListener("change", function (event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function (e) {
        try {
          methodData = JSON.parse(e.target.result);
          renderTable();
        } catch (err) {
          alert("Invalid JSON file");
          console.error(err);
        }
      };
      reader.readAsText(file);
    });

    document.getElementById("returnTypeInput").addEventListener("input", function (e) {
      debouncedRenderTable(
        document.getElementById("searchInput").value,
        e.target.value,
        document.getElementById("tagFilter").value,
        document.getElementById("typeFilter").value
      );
    });

    document.getElementById("searchInput").addEventListener("input", function (e) {
      debouncedRenderTable(
        e.target.value,
        document.getElementById("returnTypeInput").value,
        document.getElementById("tagFilter").value,
        document.getElementById("typeFilter").value
      );
    });

    document.getElementById("tagFilter").addEventListener("change", function (e) {
      renderTable(
        document.getElementById("searchInput").value, 
        document.getElementById("returnTypeInput").value,
        e.target.value, 
        document.getElementById("typeFilter").value
      );
    });

    document.getElementById("typeFilter").addEventListener("change", function (e) {
      renderTable(
        document.getElementById("searchInput").value, 
        document.getElementById("returnTypeInput").value,
        document.getElementById("tagFilter").value, 
        e.target.value
      );
    });

    document.querySelectorAll("th[data-sort]").forEach(th => {
      th.addEventListener("click", () => {
        const field = th.getAttribute("data-sort");
        if (sortField === field) {
          sortAsc = !sortAsc;
        } else {
          sortField = field;
          sortAsc = true;
        }
        document.querySelectorAll("th").forEach(th => th.classList.remove("sort-asc", "sort-desc"));
        th.classList.add(sortAsc ? "sort-asc" : "sort-desc");
        renderTable(
          document.getElementById("searchInput").value, 
          document.getElementById("tagFilter").value, 
          document.getElementById("typeFilter").value
        );
      });
    });
  </script>
</body>
</html>