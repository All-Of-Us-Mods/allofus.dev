<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>IL2CPP Mono Method Analyzer</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      background-color: #f4f4f4;
    }

    h1 {
      margin-bottom: 10px;
    }

    .tag {
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.85em;
      font-weight: bold;
      display: inline-block;
    }

    .inlined {
      background-color: #d1e7dd;
      color: #0f5132;
    }

    .used-by-inline {
      background-color: #f8d7da;
      color: #842029;
    }

    .stripped {
      background-color: #e2e3e5;
      color: #41464b;
    }

    .matched {
      background-color: #cfe2ff;
      color: #084298;
    }

    .highlight {
      background-color: yellow;
      font-weight: bold;
    }
    
    .filters {
      display: flex;
      gap: 10px;
      margin: 10px 0;
      flex-wrap: wrap;
    }

    #searchInput, #returnTypeInput, #tagFilter, #typeFilter {
      margin-bottom: 10px;
      padding: 6px 10px;
      box-sizing: border-box;
      flex: 1;
      min-width: 150px;
    }

    #searchInput {
      flex: 4;
    }

    .count-display {
      margin-top: 10px;
      font-size: 20px; 
      color: #222;
      padding: 5px;
      background-color: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 4px;
      display: inline-block;
    }

    .usage-window {
      position: fixed;
      width: 600px;
      max-height: 60vh;
      background-color: white;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      display: flex;
      flex-direction: column;
      z-index: 100;
      right: 20px;
      top: 20px;
      resize: both;
      overflow: hidden;
      min-width: 300px;
      min-height: 200px;
    }

    .usage-window::-webkit-resizer {
      display: none;
    }

    .resize-handle {
      position: absolute;
      right: 0;
      bottom: 0;
      width: 15px;
      height: 15px;
      background: linear-gradient(135deg, #ddd 0%, #ddd 50%, transparent 50%);
      cursor: nwse-resize;
      z-index: 10;
    }

    .usage-window:not(:first-of-type) {
      margin-top: 30px;
    }
    
    .window-header {
      background-color: #f0f0f0;
      padding: 10px 15px;
      cursor: move;
      border-bottom: 1px solid #ddd;
      font-weight: bold;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-top-left-radius: 4px;
      border-top-right-radius: 4px;
      word-break: break-word;
      white-space: pre-wrap;
    }
    
    .window-close {
      cursor: pointer;
      font-size: 36px;
      line-height: 1;
    }
    
    .window-body {
      padding: 15px;
      overflow-y: auto;
      flex-grow: 1;
    }
    
    .usage-item {
      padding: 8px 12px;
      border-bottom: 1px solid #eee;
      font-family: monospace;
      font-size: 13px;
      display: flex;
      align-items: center;
    }
    
    .usage-item:last-child {
      border-bottom: none;
    }
    
    .no-usages {
      color: #666;
      font-style: italic;
    }

    .copy-btn {
      background-color: #f0f0f0;
      border: 1px solid #ddd;
      border-radius: 4px;
      cursor: pointer;
      color: #555;
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-right: 8px;
      padding: 0;
      transition: all 0.2s ease;
      flex-shrink: 0;
    }

    .copy-btn:hover {
      background-color: #e0e0e0;
      color: #333;
    }

    .copy-btn:active {
      background-color: #d0d0d0;
    }

    .copy-btn::before {
      content: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='14' height='14' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Crect x='9' y='9' width='13' height='13' rx='2' ry='2'%3E%3C/rect%3E%3Cpath d='M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1'%3E%3C/path%3E%3C/svg%3E");
      display: inline-block;
      vertical-align: middle;
    }

    .copy-btn.copy-flash::before {
      content: "✓";
      color: green;
    }

    .copy-btn.copy-error::before {
      content: "✗";
      color: red;
    }

    .usage-section {
      margin-bottom: 20px;
    }

    .usage-section h4 {
      margin: 0 0 8px 0;
      padding-bottom: 4px;
      border-bottom: 1px solid #eee;
      color: #555;
    }

    .mono-only {
      background-color: rgba(213, 245, 227, 0.3);
      border-left: 3px solid #0f5132;
      padding-left: 5px;
    }

    .xref-only {
      background-color: rgba(255, 231, 217, 0.3);
      border-left: 3px solid #0f5132;
      padding-left: 5px;
    }

    .usage-item.common {
      border-left: 3px solid #cfe2ff;
      padding-left: 5px;
    }

    .section-header {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      padding: 5px 0;
      user-select: none;
    }

    .section-header h4 {
      margin: 0;
      color: #555;
    }

    .toggle-btn {
      background: none;
      border: none;
      cursor: pointer;
      padding: 0;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      color: #666;
    }

    .section-content {
      padding-left: 20px;
      transition: all 0.2s ease;
    }

    .section-header:hover {
      background-color: #f8f9fa;
    }

    .toggle-btn:hover {
      color: #333;
    }
  
    @keyframes copyFlash {
      0% { color: green; }
      100% { color: #666; }
    }

    .copy-flash {
      animation: copyFlash 1s;
    }

    .virtual-table {
      width: 100%;
      max-height: 65vh;
      border: 1px solid #ddd;
      background: white;
      display: flex;
      flex-direction: column;
      font-size: 14px;
    }

    .virtual-header {
      display: flex;
      background: #f0f0f0;
      font-weight: bold;
      position: sticky;
      top: 0;
      z-index: 5;
      border-bottom: 1px solid #ddd;
    }

    .virtual-header .cell {
      padding: 6px 8px;
      border-right: 1px solid #ddd;
      word-break: break-word;
      white-space: pre-wrap;
      cursor: pointer;
    }

    .virtual-header .cell.sort-asc::before {
      content: "▲";
    }

    .virtual-header .cell.sort-desc::before {
      content: "▼";
    }

    .virtual-viewport {
      overflow-y: auto;
      flex: 1;
      position: relative;
    }

    .virtual-spacer {
      height: 0;
    }

    .virtual-content {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
    }

    .row {
      display: flex;
      border-top: 1px solid #ddd;
      padding: 0 0;
      cursor: pointer;
      background: white;
      align-items: stretch;
    }

    .row:hover {
      background-color: #f5f5f5;
    }

    .cell {
      padding: 6px 8px;
      word-break: break-word;
      white-space: pre-wrap;
      display: flex;
      flex-grow: 1;
      flex-shrink: 0;
      align-items: center;
      border-right: 1px solid #ddd;
    }

    .col-method   { width: 45%; flex-shrink: 0; }
    .col-return   { width: 12%; flex-shrink: 0; }
    .col-count    { width: 7%; flex-shrink: 0; }
    .col-type     { width: 5%; flex-shrink: 0; }
    .col-tag      { width: 13%; flex-shrink: 0; }

  </style>
</head>
<body>
  <h1>IL2CPP Mono Methods Analyzer</h1>
  <div class="upload-inputs">
    <input type="file" id="fileInput" accept="application/json" />
    <button onclick="loadOnline()">Load Latest Online JSON</button>
  </div>
  <div class="filters">
    <input type="text" id="searchInput" placeholder="Search methods..." />
    <input type="text" id="returnTypeInput" placeholder="Search return types..." />
    <select id="tagFilter">
      <option value="">All Tags</option>
      <option value="inlined">Potentially Inlined</option>
      <option value="used-by-inline">Potentially used by Inlined method</option>
      <option value="stripped">Potentially Stripped</option>
      <option value="matched">Matched</option>
    </select>
    <select id="typeFilter">
      <option value="">All Types</option>
      <option value="Method">Method</option>
      <option value="Property">Property</option>
    </select>
  </div>
  <div id="countDisplay" class="count-display">0/0</div>
  <div class="virtual-table">
    <div class="virtual-header">
      <div class="cell col-method" data-sort="method">Method</div>
      <div class="cell col-return" data-sort="ReturnType">Return Type</div>
      <div class="cell col-count" data-sort="MonoCount">Mono Count</div>
      <div class="cell col-count" data-sort="XrefCount">Xref Count</div>
      <div class="cell col-type" data-sort="type">Type</div>
      <div class="cell col-tag" data-sort="tag">Tag</div>
    </div>    
    <div id="virtual-viewport" class="virtual-viewport">
      <div id="virtual-spacer" class="virtual-spacer"></div>
      <div id="virtual-content" class="virtual-content"></div>
    </div>
  </div>  

  <script> 
    let methodData = {};
    let allEntries = [];
    let visibleEntries = [];
    let sortField = null;
    let sortAsc = true;
    
    const openWindows = new Set();

    let rowHeights = [];
    let totalHeight = 0;
    let scrollTop = 0;

    function updateDatasetFromJson() {
      allEntries = Object.entries(methodData).map(([method, data]) => {
        let tag = "Matched";
        let tagClass = "matched";
        if (data.MonoCount > data.XrefCount) {
          tag = "Potentially Inlined";
          tagClass = "inlined";
        } else if (data.XrefCount > data.MonoCount) {
          tag = "Potentially used by Inlined method";
          tagClass = "used-by-inline";
        }
        if (data.IsStripped) {
          tag = "Potentially Stripped";
          tagClass = "stripped";
        }

        return {
          method,
          ReturnType: data.ReturnType,
          MonoCount: data.MonoCount,
          XrefCount: data.XrefCount,
          type: data.IsProperty ? "Property" : "Method",
          tag,
          tagClass
        };
      });

      renderVirtualTable();
    }

    function renderVirtualTable() {
      const filter = document.getElementById("searchInput").value.trim().toLowerCase();
      const returnTypeFilter = document.getElementById("returnTypeInput").value.trim().toLowerCase();
      const tagFilter = document.getElementById("tagFilter").value;
      const typeFilter = document.getElementById("typeFilter").value;

      visibleEntries = allEntries.filter(entry => {
        const matchesMethod = !filter || entry.method.toLowerCase().includes(filter);
        const matchesReturn = !returnTypeFilter || (entry.ReturnType.toLowerCase().includes(returnTypeFilter));
        const matchesTag = !tagFilter || entry.tagClass === tagFilter;
        const matchesType = !typeFilter || entry.type === typeFilter;
        return matchesMethod && matchesReturn && matchesTag && matchesType;
      });

      if (sortField) {
        visibleEntries.sort((a, b) => {
          const valA = a[sortField];
          const valB = b[sortField];
          if (valA < valB) return sortAsc ? -1 : 1;
          if (valA > valB) return sortAsc ? 1 : -1;
          return 0;
        });
      }

      document.getElementById("countDisplay").textContent = `${visibleEntries.length}/${allEntries.length}`;
      rowHeights = new Array(visibleEntries.length).fill(40);
      totalHeight = rowHeights.reduce((a, b) => a + b, 0);
      document.getElementById("virtual-spacer").style.height = totalHeight + "px";
      renderVisibleRows();
    }

    function renderVisibleRows() {
      const container = document.getElementById("virtual-viewport");
      const content = document.getElementById("virtual-content");
      scrollTop = container.scrollTop;
      const height = container.clientHeight;

      let start = 0;
      let offset = 0;
      while (offset + (rowHeights[start] || 40) < scrollTop && start < rowHeights.length) {
        offset += rowHeights[start];
        start++;
      }

      let end = start;
      let visibleHeight = 0;
      while (visibleHeight < height && end < rowHeights.length) {
        visibleHeight += rowHeights[end];
        end++;
      }

      content.innerHTML = '';
      let y = offset;

      for (let i = start; i < end; i++) {
        const entry = visibleEntries[i];
        const row = document.createElement("div");
        row.className = "row";
        row.style.position = "absolute";
        row.style.top = y + "px";
        row.style.left = 0;
        row.style.right = 0;

        row.innerHTML = `
          <div class="cell col-method">
            <button class="copy-btn" title="Copy"></button>
            <span class="method-name">${highlightMatch(entry.method, document.getElementById("searchInput").value)}</span>
          </div>
          <div class="cell col-return">
            <span class="return-type">${highlightMatch(entry.ReturnType, document.getElementById("returnTypeInput").value)}</span>
          </div>
          <div class="cell col-count">${entry.MonoCount}</div>
          <div class="cell col-count">${entry.XrefCount}</div>
          <div class="cell col-type">${entry.type}</div>
          <div class="cell col-tag"><span class="tag ${entry.tagClass}">${entry.tag}</span></div>
        `;
        const copyBtn = row.querySelector(".copy-btn");
        setupCopyButton(copyBtn, entry.method);

        row.addEventListener('click', () => showUsages(entry.method));
        content.appendChild(row);

        requestAnimationFrame(() => {
          const h = row.getBoundingClientRect().height;
          if (h !== rowHeights[i]) {
            rowHeights[i] = h;
            document.getElementById("virtual-spacer").style.height =
              rowHeights.reduce((a, b) => a + b, 0) + "px";
          }
        });

        y += rowHeights[i] || 40;
      }
    }

    document.getElementById("virtual-viewport").addEventListener("scroll", renderVisibleRows);

    function setupCopyButton(button, textToCopy) {
      button.addEventListener('click', (e) => {
          e.stopPropagation();
          navigator.clipboard.writeText(textToCopy).then(() => {
              button.classList.add('copy-flash');
              setTimeout(() => {
                  button.classList.remove('copy-flash');
              }, 1000);
          }).catch(err => {
              button.classList.add('copy-error');
              setTimeout(() => {
                  button.classList.remove('copy-error');
              }, 1000);
              console.error('Failed to copy:', err);
          });
      });
    }

    function createUsageWindow(methodName) {
      const method = methodData[methodName];
      if (!method) return;
          
      const windowEl = document.createElement('div');
      const windowId = 'window-' + Date.now();

      windowEl.className = 'usage-window';
      windowEl.id = windowId;
      
      const header = document.createElement('div');
      header.className = 'window-header';
      
      const title = document.createElement('span');
      title.className = 'window-title';
      title.textContent = `Usages of: ${methodName}`;
      
      const closeBtn = document.createElement('span');
      closeBtn.className = 'window-close';
      closeBtn.textContent = '×';
      
      header.append(title, closeBtn);
      windowEl.append(header);
      
      const body = document.createElement('div');
      body.className = 'window-body';
      
      const monoSection = createUsageSection(
        'Mono Usages', 
        method.MonoUsages, 
        method.XrefUsages,
        'mono-only'
      );
      body.append(monoSection);
      
      const xrefSection = createUsageSection(
        'Xref Usages',
        method.XrefUsages,
        method.MonoUsages,
        'xref-only'
      );
      body.append(xrefSection);
      
      windowEl.append(body);

      const resizeHandle = document.createElement('div');
      resizeHandle.className = 'resize-handle';
      windowEl.appendChild(resizeHandle);

      function createUsageSection(title, items, compareItems, diffClass) {
        const section = document.createElement('div');
        section.className = 'usage-section';
        
        const header = document.createElement('div');
        header.className = 'section-header';
        header.dataset.section = title.toLowerCase().replace(' ', '-');
        
        const toggleBtn = document.createElement('button');
        toggleBtn.className = 'toggle-btn';
        toggleBtn.textContent = '▼';
        
        const titleEl = document.createElement('h4');
        titleEl.textContent = `${title} (${items?.length || 0})`;
        
        header.append(toggleBtn, titleEl);
        section.append(header);
        
        const content = document.createElement('div');
        content.className = `section-content ${header.dataset.section}-section`;
        
        if (!items || items.length === 0) {
            const noItems = document.createElement('div');
            noItems.className = 'no-usages';
            noItems.textContent = `No ${title} found`;
            content.append(noItems);
        } else {
          items.forEach(usage => {
            const item = document.createElement('div');
            item.className = 'usage-item';
            
            const copyBtn = document.createElement('button');
            copyBtn.className = 'copy-btn';
            copyBtn.title = 'Copy to clipboard';
            
            const usageText = document.createElement('span');
            usageText.textContent = usage;
            usageText.style.flexGrow = '1';
            
            item.append(copyBtn, usageText);
            
            setupCopyButton(copyBtn, usage);
            
            if (compareItems && !compareItems.includes(usage)) {
                item.classList.add(diffClass);
            }
            
            content.append(item);
          });
        }
        
        section.append(content);
        return section;
    }
      
      windowEl.querySelectorAll('.section-header').forEach(header => {
        header.addEventListener('click', (e) => {
          if (e.target.classList.contains('toggle-btn')) return;
          
          const btn = header.querySelector('.toggle-btn');
          const section = header.nextElementSibling;
          section.style.display = section.style.display === 'none' ? 'block' : 'none';
          btn.textContent = section.style.display === 'none' ? '▶' : '▼';
        });
      });

      windowEl.querySelectorAll('.toggle-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const header = e.target.closest('.section-header');
          const section = header.nextElementSibling;
          section.style.display = section.style.display === 'none' ? 'block' : 'none';
          btn.textContent = section.style.display === 'none' ? '▶' : '▼';
        });
      });
      
      document.body.appendChild(windowEl);
      openWindows.add(windowId);
      
      setupWindowDrag(windowEl);
      setupWindowResize(windowEl, resizeHandle);
      
      closeBtn.addEventListener('click', () => {
        document.body.removeChild(windowEl);
        openWindows.delete(windowId);
      });
      
      return windowEl;
    }
    
    function setupWindowDrag(windowEl) {
      const header = windowEl.querySelector('.window-header');
      let isDragging = false;
      let offsetX, offsetY;
      
      header.addEventListener('mousedown', (e) => {
        if (e.target.classList.contains('window-close') || 
            e.target.classList.contains('resize-handle')) {
          return;
        }
        
        isDragging = true;
        offsetX = e.clientX - windowEl.getBoundingClientRect().left;
        offsetY = e.clientY - windowEl.getBoundingClientRect().top;
        windowEl.style.cursor = 'grabbing';
        e.preventDefault();
      });
      
      document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        
        windowEl.style.left = `${e.clientX - offsetX}px`;
        windowEl.style.top = `${e.clientY - offsetY}px`;
        windowEl.style.right = 'auto';
      });
      
      document.addEventListener('mouseup', () => {
        isDragging = false;
        windowEl.style.cursor = '';
      });
    }
    
    function setupWindowResize(element, handle) {
      let startX, startY, startWidth, startHeight;

      function initResize(e) {
        e.preventDefault();
        startX = e.clientX;
        startY = e.clientY;
        startWidth = parseInt(document.defaultView.getComputedStyle(element).width, 10);
        startHeight = parseInt(document.defaultView.getComputedStyle(element).height, 10);
        document.addEventListener('mousemove', resize);
        document.addEventListener('mouseup', stopResize);
      }

      function resize(e) {
        element.style.width = (startWidth + e.clientX - startX) + 'px';
        element.style.height = (startHeight + e.clientY - startY) + 'px';
      }

      function stopResize() {
        document.removeEventListener('mousemove', resize);
        document.removeEventListener('mouseup', stopResize);
      }

      handle.addEventListener('mousedown', initResize);
    }

    function showUsages(methodName) {
      createUsageWindow(methodName);
    }

    function updateCountDisplay() {
      document.getElementById("countDisplay").textContent = `${filteredCount}/${totalCount}`;
    }

    function highlightMatch(text, filter) {
      if (!filter) return escapeHTML(text);

      const lowerText = text.toLowerCase();
      const lowerFilter = filter.toLowerCase();
      const fragment = document.createDocumentFragment();
      
      let lastIndex = 0;
      let index = lowerText.indexOf(lowerFilter);

      while (index !== -1) {
        if (index > lastIndex) {
          fragment.appendChild(document.createTextNode(text.slice(lastIndex, index)));
        }

        const highlightSpan = document.createElement('span');
        highlightSpan.className = 'highlight';
        highlightSpan.textContent = text.slice(index, index + filter.length);
        fragment.appendChild(highlightSpan);

        lastIndex = index + filter.length;
        index = lowerText.indexOf(lowerFilter, lastIndex);
      }

      if (lastIndex < text.length) {
        fragment.appendChild(document.createTextNode(text.slice(lastIndex)));
      }

      const container = document.createElement('div');
      container.appendChild(fragment);
      return container.innerHTML;
    }

    function escapeHTML(str) {
      const div = document.createElement("div");
      div.innerText = str;
      return div.innerHTML;
    }

    function debounce(func, wait) {
      let timeout;
      return function(...args) {
        const context = this;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), wait);
      };
    }

    function loadOnline() {
      fetch("method_analysis_results.json")
        .then(response => response.json())
        .then(data => {
          methodData = data;
          updateDatasetFromJson();
        })
        .catch(err => {
          alert("Failed to load online JSON");
          console.error(err);
        });
    }

    document.getElementById("fileInput").addEventListener("change", function (event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function (e) {
        try {
          methodData = JSON.parse(e.target.result);
          updateDatasetFromJson();
        } catch (err) {
          alert("Invalid JSON file");
          console.error(err);
        }
      };

      reader.readAsText(file);
    });

    document.getElementById("searchInput").addEventListener("input", debounce(renderVirtualTable, 200));
    document.getElementById("returnTypeInput").addEventListener("input", debounce(renderVirtualTable, 200));
    document.getElementById("tagFilter").addEventListener("change", renderVirtualTable);
    document.getElementById("typeFilter").addEventListener("change", renderVirtualTable);

    document.querySelectorAll(".virtual-header .cell").forEach(th => {
      th.addEventListener("click", () => {
        const field = th.dataset.sort;
        if (sortField === field) {
          sortAsc = !sortAsc;
        } else {
          sortField = field;
          sortAsc = true;
        }
        

        // Clear all arrows
        document.querySelectorAll(".virtual-header .cell").forEach(cell => {
          cell.classList.remove("sort-asc", "sort-desc");
        });

        // Add arrow to selected header
        th.classList.add(sortAsc ? "sort-asc" : "sort-desc");

        renderVirtualTable();
      });
    });

  </script>
</body>
</html>